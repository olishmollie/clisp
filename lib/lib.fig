(define lib "lib/lib.fig")

(define (caar l) (car (car l)))
(define (cadr l) (car (cdr l)))
(define (cdar l) (cdr (car l)))
(define (cddr l) (cdr (cdr l)))
(define (caaar l) (car (car (car l))))
(define (caadr l) (car (car (cdr l))))
(define (cadar l) (car (cdr (car l))))
(define (caddr l) (car (cdr (cdr l))))

;; math
(define (= x y)
  (if (and (number? x) (number? y))
      (eq? x y)
      #f))

(define (identity x) x)

(define (abs x) (if (< x 0) (- x) x))

(define (fact n)
  (define (iter prod count max)
    (if (> count max)
        prod
        (iter (* count prod)
              (+ count 1)
              max)))
  (iter 1 1 n))

(define (** base exp)
  (define (iter prod count max)
    (if (eq? count max)
        prod
        (iter (* base prod)
              (+ count 1)
              max)))
  (iter base 1 exp))

(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))

(define (fib n)
  (define (iter cur prev count max)
    (if (>= count max)
        cur
        (iter (+ cur prev)
              cur
              (+ 1 count)
              max)))
  (iter 1 0 1 n))

(define (vec2 x y) (list x y))
(define (vec3 x y z) (list x y z))

(define (dot a b)
  (if (or (null? a) (null? b))
      0
      (+ (* (car a) (car b))
         (dot (cdr a) (cdr b)))))

;; lists
(define (list-ref seq n)
  (if (eq? n 0)
      (car seq)
      (list-ref (cdr seq) (- n 1))))

(define (length seq)
  (if (null? seq)
      0
      (+ 1 (length (cdr seq)))))

(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))

(define (last-pair seq)
  (if (null? (cdr seq))
      seq
      (last-pair (cdr seq))))

(define (reverse seq)
  (if (null? seq)
      seq
      (append (reverse (cdr seq)) (list (car seq)))))

(define (map proc seq)
  (if (null? seq)
      seq
      (cons (proc (car seq))
            (map proc (cdr seq)))))

(define count
  ((lambda (total)
    (lambda (increment)
      (set! total (+ total increment))
      total))
  0))