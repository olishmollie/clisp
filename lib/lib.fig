(define (abs x)
    (if (< x 0)
        (- x)
        x))

(define (= x y)
    (if (and (eq (type x) "number") (eq (type y) "number"))
        (eq x y)
        (error "args to = must be numbers")))

(define newline "\n")

(define null? (lambda (x)
    (cond ((atom x) (eq x '()))
          (#t #f))))

(define not (lambda (x)
    (cond (x #f)
          (#t #t))))

(define and (lambda (x y)
    (if x
        (if y #t #f)
        #f)))

(define or (lambda (x y)
    (cond (x #t)
          (#t (cond (y #t)
                      (#t #f))))))

(define inc (lambda (x)
    (+ x 1)))

(define dec (lambda (x)
    (- x 1)))

(define equal? (lambda (a b)
    (cond ((and (atom a) (atom b)) (eq a b))
          ((or (atom a) (atom b)) #f)
          (#t (equal? (cdr a) (cdr b))))))

(define (square x) (* x x))
(define (cube x) (* x x x))
(define (average x y) (/ (+ x y) 2))

(define (sqrt x)
    (define (good-enough? guess)
        (< (abs (- (square guess) x)) 0.001))
    (define (improve guess)
        (average guess (/ x guess)))
    (define (sqrt-iter guess)
        (if (good-enough? guess)
            guess
            (sqrt-iter (improve guess))))
    (sqrt-iter 1.0))

(define (A x y)
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))

(define (pow b n)
    (define (pow-iter b counter product)
        (if (= counter 0)
            product
            (pow-iter b
                      (- counter 1)
                      (* b product))))
    (pow-iter b n 1))

(define (gcd a b)
    (if (= b 0)
        a
        (gcd b (mod a b))))

(define (f x y)
    (let ((a (+ 1 (* x y)))
          (b (- 1 y)))
        (+ (* x (square a))
           (* y b)
           (* a b))))