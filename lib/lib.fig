(def newline "\n")
(def null? (lambda (x)
    (cond ((atom x) (eq x '()))
          (#t #f))))

(def not (lambda (x)
    (cond (x #f)
          (#t #t))))
(def and (lambda (x y)
    (cond (x
           (cond (y #t)
                 (#t #f)))
          (#t #f))))
(def or (lambda (x y)
    (cond (x #t)
          (#t (cond (y #t)
                      (#t #f))))))
(def for-each (lambda (fn l)
    (cond ((null? (cdr l)) (cons (fn (car l)) (cdr l)))
          (#t (cons (fn (car l)) (for-each fn (cdr l)))))))
(def incr (lambda (x)
    (+ x 1)))
(def decr (lambda (x)
    (- x 1)))
(def equal? (lambda (a b)
    (cond ((and (atom a) (atom b)) (eq a b))
          ((or (atom a) (atom b)) #f)
          (#t (equal? (cdr a) (cdr b))))))
(def append (lambda (x y
    (cond ((null? x) y)
           (#t (cons (car x) (append (cdr x) y)))))))
(def fact (lambda (n)
    (def fact-iter (lambda (prod count max)
        (cond ((> count max) prod)
              (#t (fact-iter (* count prod)
                               (+ count 1)
                               max)))))
    (fact-iter 1 1 n)))

(def abs (lambda (x)
    (cond ((< x 0) (* -1 x)) (#t x))))
(def average (lambda (x y)
    (/ (+ x y) 2)))
(def square (lambda (x) (* x x)))

(def sqrt (lambda (x)
    (def good-enough? (lambda (guess x)
        (< (abs (- (square guess) x)) 0.001)))
    (def improve (lambda (guess x)
        (average guess (/ x guess))))
    (def sqrt-iter (lambda (guess x)
        (cond ((good-enough? guess x) guess)
              (#t (sqrt-iter (improve guess x) x)))))
    (sqrt-iter 1.0 x)))