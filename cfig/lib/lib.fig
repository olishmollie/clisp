(define lib "lib/lib.fig")

(define (list . x) x)

(define (error msg fn-name)
  (display (string-append "Error: " msg) fn-name))

(define (caar l) (car (car l)))
(define (cadr l) (car (cdr l)))
(define (cdar l) (cdr (car l)))
(define (cddr l) (cdr (cdr l)))
(define (caaar l) (car (car (car l))))
(define (caadr l) (car (car (cdr l))))
(define (cadar l) (car (cdr (car l))))
(define (cdaar l) (cdr (car (car l))))
(define (cddar l) (cdr (cdr (car l))))
(define (cdadr l) (cdr (car (cdr l))))
(define (caddr l) (car (cdr (cdr l))))
(define (cdddr l) (cdr (cdr (cdr l))))

;; types/equality/comparison
(define (not x)
  (if x #f #t))

(define (atom? x)
  (not (pair? x)))

(define (= x y)
  (if (and (number? x) (number? y))
      (eq? x y)
      #f))

(define (equal? x y)
  (cond ((and (null? x) (null? y)) #t)
        ((and (number? x) (number? y)) (= x y))
        ((and (atom? x) (atom? y)) (eq? x y))
        ((and (pair? x) (pair? y))
         (and (equal? (car x) (car y))
              (equal? (cdr x) (cdr y))))
        (else #f)))

;; math
(define (identity x) x)

(define (abs x) (if (< x 0) (- x) x))

(define (square x) (* x x))

(define (fact n)
  (define (iter prod count max)
    (if (> count max)
        prod
        (iter (* count prod)
              (+ count 1)
              max)))
  (iter 1 1 n))

(define (** base exp)
  (define (iter prod count max)
    (if (eq? count max)
        prod
        (iter (* base prod)
              (+ count 1)
              max)))
  (iter base 1 exp))

(define (fib n)
  (define (iter cur prev count max)
    (if (>= count max)
        cur
        (iter (+ cur prev)
              cur
              (+ 1 count)
              max)))
  (iter 1 0 1 n))

(define (vec . x) x)

(define (dot a b)
  (if (or (null? a) (null? b))
      0
      (+ (* (car a) (car b))
         (dot (cdr a) (cdr b)))))

(define (veclen vec)
  (define (len vec)
    (if (null? vec)
        0
        (+ (square (car vec))
           (len (cdr vec)))))
  (list 'sqrt (len vec)))

(define (orthogonal? va vb)
  (= (dot va vb) 0))

;; lists
(define (memq item seq)
  (cond ((null? seq) #f)
        ((eq? item (car seq)) seq)
        (else (memq item (cdr seq)))))

(define (list-ref seq n)
  (if (eq? n 0)
      (car seq)
      (list-ref (cdr seq) (- n 1))))

(define (length seq)
  (if (null? seq)
      0
      (+ 1 (length (cdr seq)))))

(define (range n)
  (define (iter count max)
    (if (>= count max)
        '()
        (cons count (iter (+ count 1) max))))
  (iter 0 n))

(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))

(define (last-pair seq)
  (if (null? (cdr seq))
      seq
      (last-pair (cdr seq))))

(define (reverse seq)
  (if (null? seq)
      seq
      (append (reverse (cdr seq)) (list (car seq)))))

(define (map proc seq)
  (if (null? seq)
      seq
      (cons (proc (car seq))
            (map proc (cdr seq)))))

(define (reduce proc seq mem)
  (if (null? seq)
      mem
      (proc (car seq) (reduce proc (cdr seq) mem))))

(define count
  ((lambda (total)
    (lambda (increment)
      (set! total (+ total increment))
      total))
  0))